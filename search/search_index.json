{
    "docs": [
        {
            "location": "/",
            "text": "zend-expressive-csrf\n\n\n\n\n\n\nProvides CSRF token generation and validation for PSR-7 applications, using\n\nzend-expressive-session\n,\nand optionally \nzend-expressive-flash\n.\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require zendframework/zend-expressive-csrf\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build\n\n\n\nYou may also \nbrowse the documentation online\n.",
            "title": "zend-expressive-csrf"
        },
        {
            "location": "/#zend-expressive-csrf",
            "text": "Provides CSRF token generation and validation for PSR-7 applications, using zend-expressive-session ,\nand optionally  zend-expressive-flash .",
            "title": "zend-expressive-csrf"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require zendframework/zend-expressive-csrf",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build  You may also  browse the documentation online .",
            "title": "Documentation"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nCross-Site Request Forgery\n\n(CSRF) is a security vector in which an unauthorized request is accepted by a server on\nbehalf of another user; it is essentially an exploit of the trust a site places\non a user's browser.\n\n\nThe typical mitigation is to create a one-time token that is transmitted as part\nof the original form, and which must then be transmitted back by the client.\nThis token \nexpires\n after first submission or after a short amount of time,\npreventing replays or further submissions. If the token provided does not match\nwhat was originally sent, an error should be returned.\n\n\nzend-expressive-csrf provides utilities for both generating CSRF tokens, as well\nas validating them. Tokens are stored within a session, and expire after any\nattempt to validate.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#introduction",
            "text": "Cross-Site Request Forgery \n(CSRF) is a security vector in which an unauthorized request is accepted by a server on\nbehalf of another user; it is essentially an exploit of the trust a site places\non a user's browser.  The typical mitigation is to create a one-time token that is transmitted as part\nof the original form, and which must then be transmitted back by the client.\nThis token  expires  after first submission or after a short amount of time,\npreventing replays or further submissions. If the token provided does not match\nwhat was originally sent, an error should be returned.  zend-expressive-csrf provides utilities for both generating CSRF tokens, as well\nas validating them. Tokens are stored within a session, and expire after any\nattempt to validate.",
            "title": "Introduction"
        },
        {
            "location": "/guard/",
            "text": "CSRF Guards\n\n\nTo provide CSRF protection, we provide an abstraction,\n\nZend\\Expressive\\Csrf\\CsrfGuardInterface\n:\n\n\nnamespace Zend\\Expressive\\Csrf;\n\ninterface CsrfGuardInterface\n{\n    /**\n     * Generate a CSRF token.\n     *\n     * Typically, implementations should generate a one-time CSRF token,\n     * store it within the session, and return it so that developers may\n     * then inject it in a form, a response header, etc.\n     *\n     * CSRF tokens should EXPIRE after the first hop.\n     */\n    public function generateToken(string $keyName = '__csrf') : string;\n\n    /**\n     * Validate whether a submitted CSRF token is the same as the one stored in\n     * the session.\n     *\n     * CSRF tokens should EXPIRE after the first hop.\n     */\n    public function validateToken(string $token, string $csrfKey = '__csrf') : bool;\n}\n\n\n\nBecause guards will be backed by different mechanisms, we provide\n\nCsrfMiddleware\n that will generate the guard based on\nconfiguration, and inject it into the request passed to later middleware; this\napproach allows you to separate generation fo the guard instance (which is based\non request data) from your own middleware.\n\n\nOnce you have a concrete implementation, you will generally:\n\n\n\n\nGenerate\n a token in middleware displaying a form, and\n\n\nValidate\n a token in middleware validating that form.\n\n\n\n\nAs an example, we could have middleware displaying a form as follows:\n\n\nnamespace Books;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Csrf\\CsrfGuardInterface;\nuse Zend\\Expressive\\Csrf\\CsrfMiddleware;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass DisplayBookFormHandler implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $guard = $request->getAttribute(CsrfMiddleware::GUARD_ATTRIBUTE);\n        $token = $guard->generateToken();\n\n        return new HtmlResponse(\n            $this->renderer->render('books::form', [\n                '__csrf' => $token,\n            ]);\n        );\n    }\n}\n\n\n\nWhen we're ready to process it, we then might have the following middleware:\n\n\nnamespace Books;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Csrf\\CsrfGuardInterface;\nuse Zend\\Expressive\\Csrf\\CsrfMiddleware;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass ProcessBookFormHandler implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $guard = $request->getAttribute(CsrfMiddleware::GUARD_ATTRIBUTE);\n        $data  = $request->getParsedBody();\n        $token = $data['__csrf'] ?? '';\n\n        if (! $guard->validateToken($token)) {\n            return new EmptyResponse(412); // Precondition failed\n        }\n\n        // process form normally and return a response...\n    }\n}\n\n\n\nThis approach allows you to prevent CSRF attacks \nseparately\n from normal form\nvalidation, which can also simplify how your forms are structured.\n\n\nWe provide two guard implementations, one using the base session container\nfunctionality from zend-expressive-session, and another using flash messages as\nprovided in zend-expressive-flash.\n\n\nSession-based guard\n\n\nSession-based guards are provided via \nZend\\Expressive\\Csrf\\SessionCsrfGuard\n.\nThis class expects a \nZend\\Expressive\\Session\\SessionInterface\n instance to its\nconstructor, and it then uses that to both store a token in the session during\n\ngenerateToken()\n, and when validating a submitted token.\n\n\nFlash-based guard\n\n\nFlash guards are provided via \nZend\\Expressive\\Csrf\\FlashCsrfGuard\n.  This class\nexpects a \nZend\\Expressive\\Flash\\FlashMessagesInterface\n instance to its\nconstructor, and it then uses that to store a token via a flash message when\n\ngenerateToken()\n is called, and to retrieve a previously flashed token when\nvalidating a submitted token.\n\n\nTo use this guard, you will also need to install the zend-expressive-flash\npackage:\n\n\n$ composer require zendframework/zend-expressive-flash\n\n\n\nGuard factories\n\n\nBecause guard implementations generally require request-based artifacts in order\nto do their work, we provide an interface describing a factory for generating\nguards. Essentially, each guard implementation will also supply their own\nfactory implementation, which the \nCsrfMiddleware\n will then\nconsume to create a guard instance.\n\n\nZend\\Expressive\\Csrf\\CsrfGuardFactoryInterface\n defines the following:\n\n\nnamespace Zend\\Expressive\\Csrf;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface CsrfGuardFactoryInterface\n{\n    public function createGuardFromRequest(ServerRequestInterface $request) : CsrfGuardInterface;\n}\n\n\n\nWe provide the following concrete factories:\n\n\n\n\nZend\\Expressive\\Csrf\\SessionCsrfGuardFactory\n\n\nZend\\Expressive\\Csrf\\FlashCsrfGuardFactory\n\n\n\n\nYou will need to map the appropriate one to the\n\nZend\\Expressive\\Csrf\\CsrfGuardFactoryInterface\n service in your dependency\ninjection container. By default, we map this service to the\n\nSessionCsrfGuardFactory\n.\n\n\nYou may also compose the \nCsrfGuardFactoryInterface\n directly in your own\nmiddleware. When you do, you will have to manually use it to create the guard\ninstance prior to generating or validating a token:\n\n\nclass SomeHandler implements MiddlewareInterface\n{\n    private $guardFactory;\n\n    public function __construct(CsrfGuardFactoryInterface $guardFactory)\n    {\n        $this->guardFactory = $guardFactory;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $guard = $this->guardFactory->createGuardFromRequest($request);\n        // ...\n    }\n}",
            "title": "CSRF Guards"
        },
        {
            "location": "/guard/#csrf-guards",
            "text": "To provide CSRF protection, we provide an abstraction, Zend\\Expressive\\Csrf\\CsrfGuardInterface :  namespace Zend\\Expressive\\Csrf;\n\ninterface CsrfGuardInterface\n{\n    /**\n     * Generate a CSRF token.\n     *\n     * Typically, implementations should generate a one-time CSRF token,\n     * store it within the session, and return it so that developers may\n     * then inject it in a form, a response header, etc.\n     *\n     * CSRF tokens should EXPIRE after the first hop.\n     */\n    public function generateToken(string $keyName = '__csrf') : string;\n\n    /**\n     * Validate whether a submitted CSRF token is the same as the one stored in\n     * the session.\n     *\n     * CSRF tokens should EXPIRE after the first hop.\n     */\n    public function validateToken(string $token, string $csrfKey = '__csrf') : bool;\n}  Because guards will be backed by different mechanisms, we provide CsrfMiddleware  that will generate the guard based on\nconfiguration, and inject it into the request passed to later middleware; this\napproach allows you to separate generation fo the guard instance (which is based\non request data) from your own middleware.  Once you have a concrete implementation, you will generally:   Generate  a token in middleware displaying a form, and  Validate  a token in middleware validating that form.   As an example, we could have middleware displaying a form as follows:  namespace Books;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Csrf\\CsrfGuardInterface;\nuse Zend\\Expressive\\Csrf\\CsrfMiddleware;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass DisplayBookFormHandler implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $guard = $request->getAttribute(CsrfMiddleware::GUARD_ATTRIBUTE);\n        $token = $guard->generateToken();\n\n        return new HtmlResponse(\n            $this->renderer->render('books::form', [\n                '__csrf' => $token,\n            ]);\n        );\n    }\n}  When we're ready to process it, we then might have the following middleware:  namespace Books;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Csrf\\CsrfGuardInterface;\nuse Zend\\Expressive\\Csrf\\CsrfMiddleware;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass ProcessBookFormHandler implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $guard = $request->getAttribute(CsrfMiddleware::GUARD_ATTRIBUTE);\n        $data  = $request->getParsedBody();\n        $token = $data['__csrf'] ?? '';\n\n        if (! $guard->validateToken($token)) {\n            return new EmptyResponse(412); // Precondition failed\n        }\n\n        // process form normally and return a response...\n    }\n}  This approach allows you to prevent CSRF attacks  separately  from normal form\nvalidation, which can also simplify how your forms are structured.  We provide two guard implementations, one using the base session container\nfunctionality from zend-expressive-session, and another using flash messages as\nprovided in zend-expressive-flash.",
            "title": "CSRF Guards"
        },
        {
            "location": "/guard/#session-based-guard",
            "text": "Session-based guards are provided via  Zend\\Expressive\\Csrf\\SessionCsrfGuard .\nThis class expects a  Zend\\Expressive\\Session\\SessionInterface  instance to its\nconstructor, and it then uses that to both store a token in the session during generateToken() , and when validating a submitted token.",
            "title": "Session-based guard"
        },
        {
            "location": "/guard/#flash-based-guard",
            "text": "Flash guards are provided via  Zend\\Expressive\\Csrf\\FlashCsrfGuard .  This class\nexpects a  Zend\\Expressive\\Flash\\FlashMessagesInterface  instance to its\nconstructor, and it then uses that to store a token via a flash message when generateToken()  is called, and to retrieve a previously flashed token when\nvalidating a submitted token.  To use this guard, you will also need to install the zend-expressive-flash\npackage:  $ composer require zendframework/zend-expressive-flash",
            "title": "Flash-based guard"
        },
        {
            "location": "/guard/#guard-factories",
            "text": "Because guard implementations generally require request-based artifacts in order\nto do their work, we provide an interface describing a factory for generating\nguards. Essentially, each guard implementation will also supply their own\nfactory implementation, which the  CsrfMiddleware  will then\nconsume to create a guard instance.  Zend\\Expressive\\Csrf\\CsrfGuardFactoryInterface  defines the following:  namespace Zend\\Expressive\\Csrf;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface CsrfGuardFactoryInterface\n{\n    public function createGuardFromRequest(ServerRequestInterface $request) : CsrfGuardInterface;\n}  We provide the following concrete factories:   Zend\\Expressive\\Csrf\\SessionCsrfGuardFactory  Zend\\Expressive\\Csrf\\FlashCsrfGuardFactory   You will need to map the appropriate one to the Zend\\Expressive\\Csrf\\CsrfGuardFactoryInterface  service in your dependency\ninjection container. By default, we map this service to the SessionCsrfGuardFactory .  You may also compose the  CsrfGuardFactoryInterface  directly in your own\nmiddleware. When you do, you will have to manually use it to create the guard\ninstance prior to generating or validating a token:  class SomeHandler implements MiddlewareInterface\n{\n    private $guardFactory;\n\n    public function __construct(CsrfGuardFactoryInterface $guardFactory)\n    {\n        $this->guardFactory = $guardFactory;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $guard = $this->guardFactory->createGuardFromRequest($request);\n        // ...\n    }\n}",
            "title": "Guard factories"
        },
        {
            "location": "/middleware/",
            "text": "CSRF Guard Middleware\n\n\nSince CSRF token generation and validation relies on request artifacts, we\nprovide \nZend\\Expressive\\Csrf\\CsrfMiddleware\n to generate the appropriate guard\ninstance and pass it into a request attribute.\n\n\nThis approach allows you to have a single location or specific locations where\nCSRF guards are generated, which can then be used by any middleware in your\napplication.\n\n\nThe \nCsrfMiddleware\n has the following constructor arguments:\n\n\n\n\nCsrfGuardFactoryInterface $guardFactory\n: a concrete instance to use for\n  generating the CSRF guard instance.\n\n\nstring $attributeKey\n: the name of the request attribute in which to store\n  the CSRF guard instance. Defaults to the \nCsrfMiddlewar::GUARD_ATTRIBUTE\n\n  (\"csrf\").\n\n\n\n\nWe provide and map a factory for the middleware,\n\nZend\\Expressive\\Csrf\\CsrfMiddlewareFactory\n; that factory depends on having the\nservice \nZend\\Expressive\\Csrf\\CsrfGuardFactoryInterface\n defined (by default it\nis, and points to the \nSessionCsrfGuard\n implementation).\n\n\nIf you want to override the defaults, create and map a custom factory.\n\n\nRegistering the middleware\n\n\nThe middleware depends on the \nZend\\Expressive\\Session\\SessionMiddleware\n, and\nmust be piped \nAFTER\n that middleware. It can be piped either in the\napplication pipeline, or within routed middleware.\n\n\nAs an example, in \nconfig/pipeline.php\n:\n\n\n$app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class);\n$app->pipe(\\Zend\\Expressive\\Csrf\\CsrfMiddleware::class);\n\n\n\nWithin routed middleware:\n\n\n$app->get('/user/login', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\Zend\\Expressive\\Csrf\\CsrfMiddleware::class,\n    UserLoginFormHandler::class,\n]);\n\n$app->post('/user/login', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\Zend\\Expressive\\Csrf\\CsrfMiddleware::class,\n    ProcessUserLoginHandler::class,\n]);",
            "title": "CSRF Middleware"
        },
        {
            "location": "/middleware/#csrf-guard-middleware",
            "text": "Since CSRF token generation and validation relies on request artifacts, we\nprovide  Zend\\Expressive\\Csrf\\CsrfMiddleware  to generate the appropriate guard\ninstance and pass it into a request attribute.  This approach allows you to have a single location or specific locations where\nCSRF guards are generated, which can then be used by any middleware in your\napplication.  The  CsrfMiddleware  has the following constructor arguments:   CsrfGuardFactoryInterface $guardFactory : a concrete instance to use for\n  generating the CSRF guard instance.  string $attributeKey : the name of the request attribute in which to store\n  the CSRF guard instance. Defaults to the  CsrfMiddlewar::GUARD_ATTRIBUTE \n  (\"csrf\").   We provide and map a factory for the middleware, Zend\\Expressive\\Csrf\\CsrfMiddlewareFactory ; that factory depends on having the\nservice  Zend\\Expressive\\Csrf\\CsrfGuardFactoryInterface  defined (by default it\nis, and points to the  SessionCsrfGuard  implementation).  If you want to override the defaults, create and map a custom factory.",
            "title": "CSRF Guard Middleware"
        },
        {
            "location": "/middleware/#registering-the-middleware",
            "text": "The middleware depends on the  Zend\\Expressive\\Session\\SessionMiddleware , and\nmust be piped  AFTER  that middleware. It can be piped either in the\napplication pipeline, or within routed middleware.  As an example, in  config/pipeline.php :  $app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class);\n$app->pipe(\\Zend\\Expressive\\Csrf\\CsrfMiddleware::class);  Within routed middleware:  $app->get('/user/login', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\Zend\\Expressive\\Csrf\\CsrfMiddleware::class,\n    UserLoginFormHandler::class,\n]);\n\n$app->post('/user/login', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\Zend\\Expressive\\Csrf\\CsrfMiddleware::class,\n    ProcessUserLoginHandler::class,\n]);",
            "title": "Registering the middleware"
        }
    ]
}